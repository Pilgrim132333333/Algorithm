#12.25
***MARRY CHRISMARS***

1.å¹³è¡¡äºŒå‰æ ‘ï¼ˆ110ï¼‰
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/balanced-binary-tree/description/
é¢˜ç›®æè¿°ï¼šç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåˆ¤æ–­å®ƒæ˜¯å¦æ˜¯ 
å¹³è¡¡äºŒå‰æ ‘

æ–¹æ³•ï¼šé€’å½’
æ€è·¯ï¼š
- é€’å½’æŸ¥æ‰¾æ¯ä¸ªç»“ç‚¹çš„å·¦å³å­æ ‘çš„é«˜åº¦ï¼Œç›¸å·®ä¸º1æˆ–0åˆ™æ ‡è®°ä¸ºtrue
- å¦åˆ™æ ‡è®°ä¸ºfalse

å®ç°ï¼š
```

class Solution {
public:
    int finddep(TreeNode* node)
    {
        if(node==nullptr)
        {
            return 0;
        }
        int leftdep=1+finddep(node->left);
        int rightdep=1+finddep(node->right);
        return max(leftdep,rightdep);
    }
    bool check(TreeNode* node)
    {
        if(node==nullptr)
        {
            return true;
        }
        int a=finddep(node->left);
        int b=finddep(node->right);
        int res=abs(a-b);
        return res<=1;
    }
    bool process(TreeNode* node)
    {
        bool res=check(node);
        if(!res)
        {
            return false;
        }
        if(node==nullptr)
        {
            return true;
        }
        
        bool a=process(node->left);
        bool b=process(node->right);
        return a&&b;
        
    }
    bool isBalanced(TreeNode* root) {
        if(root==nullptr)
        {
            return 1;
        }
        bool res=process(root);

        return res;
        
    }
};
```
æ³¨æ„ï¼š
æ­¤å¤„å®ç°æœ‰ä¸€ç‚¹éº»çƒ¦ï¼Œç­‰æˆ‘æ”¹è‰¯

***
2.äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„ï¼ˆ257ï¼‰
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/binary-tree-paths/description/
é¢˜ç›®æè¿°ï¼š
ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼ŒæŒ‰ ä»»æ„é¡ºåº ï¼Œè¿”å›æ‰€æœ‰ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„è·¯å¾„ã€‚

å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

æ–¹æ³•ï¼šé€’å½’+å›æº¯
æ€è·¯ï¼š
- è¦ç‚¹åœ¨äºå›æº¯å’Œåˆ¤æ–­æ˜¯å¦æ˜¯å¶å­
- å¦‚æœæ˜¯å¶å­é‚£ä¹ˆå°±è¦å­˜å‚¨

å®ç°
```
class Solution {
public:
    void process(TreeNode* node, string middle, vector<string>& res) {
        // Base case: If it's a leaf node, add the current path to result
        if (node == nullptr) {
            return;
        }

        // Add current node's value to the path
        middle += to_string(node->val);

        // If it's a leaf node, add the path to the result
        if (node->left == nullptr && node->right == nullptr) {
            res.push_back(middle);
        } else {
            // If not a leaf node, continue traversing to the left and right
            middle += "->";  // Add the separator for further nodes
            process(node->left, middle, res);
            process(node->right, middle, res);
        }
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> res;
        string middle="";
        process(root,middle,res);
        return res;
        
    }
};
```

æ³¨æ„ï¼š
æˆ‘è¿™é‡Œç”¨çš„æ—¶GPTæ”¹è‰¯ç‰ˆçš„ï¼Œå› ä¸ºè‡ªå·±å†™çš„ç”±äºå­—ç¬¦ä¸²å¤„ç†æœ‰é—®é¢˜å¯¼è‡´ACä¸äº†

***
3.å·¦å¶å­ä¹‹å’Œï¼ˆ404ï¼‰
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/sum-of-left-leaves/description/
é¢˜ç›®æè¿°ï¼š
ç»™å®šäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›æ‰€æœ‰å·¦å¶å­ä¹‹å’Œã€‚

æ–¹æ³•ï¼šé€’å½’åŠ æ•°ç»„
æ€è·¯ï¼š
- å°†æ‰€æœ‰å¶å­å‚¨å­˜åˆ°æ•°ç»„é‡Œ
- å†æ¬¡éå†äºŒå‰æ ‘ï¼Œå¦‚æœå‘ç°å…¶ä¸ºå·¦å¶å­ï¼Œä¾¿ç›¸åŠ 

å®ç°
```
class Solution {
public:
    void process(TreeNode* node,vector<TreeNode*> &vec)
    {
        if(node==nullptr)
        {
            return;
        }
        if(node->left==nullptr&&node->right==nullptr)
        {
            vec.push_back(node);
            return;
        }
        if(node->left)
        {
            process(node->left,vec);
        }
        if(node->right)
        {
            process(node->right,vec);
        }
        return;
        
    }
    void check(TreeNode* node,int &middle,TreeNode* tar)
    {
        if(node==nullptr)
        {
            return; 
        }
        if(node->left==tar)
        {
            middle+=tar->val;
        }
        check(node->left,middle,tar);
        check(node->right,middle,tar);
        return ;
    }
    int sumOfLeftLeaves(TreeNode* root) {
        int middle=0;
        vector<TreeNode*> vec;
        process(root,vec);
        for(auto ele:vec)
        {
            check(root,middle,ele);
        }
        return middle;
        
    }
};
```

***
4.å®Œå…¨äºŒå‰æ ‘çš„ç»“ç‚¹ä¸ªæ•°ï¼ˆ222ï¼‰
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/count-complete-tree-nodes/
é¢˜ç›®æè¿°ï¼š
ç»™ä½ ä¸€æ£µ å®Œå…¨äºŒå‰æ ‘ çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ±‚å‡ºè¯¥æ ‘çš„èŠ‚ç‚¹ä¸ªæ•°ã€‚

- å®Œå…¨äºŒå‰æ ‘ çš„å®šä¹‰å¦‚ä¸‹ï¼šåœ¨å®Œå…¨äºŒå‰æ ‘ä¸­ï¼Œé™¤äº†æœ€åº•å±‚èŠ‚ç‚¹å¯èƒ½æ²¡å¡«æ»¡å¤–ï¼Œå…¶ä½™æ¯å±‚èŠ‚ç‚¹æ•°éƒ½è¾¾åˆ°æœ€å¤§å€¼ï¼Œå¹¶ä¸”æœ€ä¸‹é¢ä¸€å±‚çš„èŠ‚ç‚¹éƒ½é›†ä¸­åœ¨è¯¥å±‚æœ€å·¦è¾¹çš„è‹¥å¹²ä½ç½®ã€‚è‹¥æœ€åº•å±‚ä¸ºç¬¬ h å±‚ï¼ˆä»ç¬¬ 0 å±‚å¼€å§‹ï¼‰ï¼Œåˆ™è¯¥å±‚åŒ…å« 1~ 2h ä¸ªèŠ‚ç‚¹ã€‚

æ–¹æ³•ï¼šé€’å½’
æ€è·¯ï¼š
- æˆ‘ç›´æ¥æ‰¾çš„ç»“ç‚¹

å®ç°ï¼š
```
class Solution {
public:
    int process(TreeNode* node)
    {
        if(node==nullptr)
        {
            return 0;
        }
        int le=process(node->left);
        int ri=process(node->right);
        return le+ri+1;
    }
    int countNodes(TreeNode* root) {
        int res=process(root);
        return res;
        
    }
};
```

***
My opinionï¼š
è¿˜æ˜¯è¦åœ¨é€’å½’å¤„å†ä¸‹ç‚¹åŠŸå¤«ï¼Œæ€»æ„Ÿè§‰åŠæ¢¦åŠè§£

**KEEEEP ğŸ•**
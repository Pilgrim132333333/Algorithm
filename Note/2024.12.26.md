#12.26

#ä»Šå¤©å°±åªæœ‰ä¸€é“é¢˜æœ‰éš¾åº¦

1.ä»ä¸­åºå’Œååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
é¢˜ç›®æè¿°ï¼š
ç»™å®šä¸¤ä¸ªæ•´æ•°æ•°ç»„ inorder å’Œ postorder ï¼Œå…¶ä¸­ inorder æ˜¯äºŒå‰æ ‘çš„ä¸­åºéå†ï¼Œ postorder æ˜¯åŒä¸€æ£µæ ‘çš„ååºéå†ï¼Œè¯·ä½ æ„é€ å¹¶è¿”å›è¿™é¢— äºŒå‰æ ‘ 

æ–¹æ³•:é€’å½’
æ€è·¯ï¼š
- ååºæ•°ç»„çš„æœ€åä¸€ä¸ªå…ƒç´ æ˜¯èŠ‚ç‚¹æ•°å€¼
- ç”¨è¿™ä¸ªæ•°ç»„åˆ†å‰²ä¸­åºæ•°ç»„å¾—å‡ºä¸¤ä¾§çš„ä¸­åºæ•°ç»„
- å†ç”¨ä¸¤ä¾§ä¸­åºæ•°ç»„åˆ†å‰²ååºæ•°ç»„ï¼Œå¾—åˆ°ä¸¤ä¾§çš„ååºæ•°ç»„

å®ç°
```
class Solution {
public:
    TreeNode* traversal(vector<int>& inorder,vector<int>& postorder)
    {
        if(inorder.size()==0||postorder.size()==0)
        {
            return NULL;
        }
        int mid=postorder.back();
        auto it = find(inorder.begin(), inorder.end(), mid);
        int index = distance(inorder.begin(), it);
        TreeNode* root=new TreeNode(mid);
        vector<int> leftInorder(inorder.begin(), inorder.begin() + index);
        vector<int> rightInorder(inorder.begin() + index + 1, inorder.end());
        
        // åˆ†å‰²ååºéå†æˆå·¦å³å­æ ‘
        // å·¦å­æ ‘çš„å¤§å°ç­‰äºå·¦å­æ ‘ä¸­åºéå†çš„é•¿åº¦
        vector<int> leftPostorder(postorder.begin(), postorder.begin() + leftInorder.size());
        vector<int> rightPostorder(postorder.begin() + leftInorder.size(), postorder.end() - 1);
        root->left=traversal(leftInorder,leftPostorder);
        root->right=traversal(rightInorder,rightPostorder);
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        TreeNode* root=traversal(inorder,postorder);
        return root;

        
    }
};
```

***
MY opinionï¼š
å°±å†™äº†ä¸€é“é¢˜çš„ç¬”è®°ï¼Œå‰©ä¸‹ä¸¤é“å¤ªç®€å•äº†
ğŸ•
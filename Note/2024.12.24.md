#12.24

1ã€‚ç¿»è½¬äºŒå‰æ ‘ï¼ˆ226ï¼‰
é¢˜ç›®è¿æ¥ï¼šhttps://leetcode.cn/problems/invert-binary-tree/description/
é¢˜ç›®æè¿°ï¼š
ç»™ä½ ä¸€æ£µäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œç¿»è½¬è¿™æ£µäºŒå‰æ ‘ï¼Œå¹¶è¿”å›å…¶æ ¹èŠ‚ç‚¹ã€‚

 æ–¹æ³•ï¼šè¿­ä»£
 æ€è·¯ï¼š
 - è¿­ä»£æ‰¾åˆ°æ¯ä¸ªç»“ç‚¹ï¼Œå¹¶å°†å…¶å·¦å³ç»“ç‚¹åè½¬

å®ç°ï¼š
```
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr)
        {
            return nullptr;
        }
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty())
        {
            TreeNode* node=st.top();
            if(node!=nullptr)
            {
                st.pop();
                if(node->right)
                {
                    st.push(node->right);
                }
                if(node->left)
                {
                    st.push(node->left);
                }
                st.push(node);
                st.push(nullptr);
            }
            else{
                st.pop();
                TreeNode* cur=st.top();
                TreeNode* temp=cur->left;
                cur->left=cur->right;
                cur->right=temp;
                st.pop();
            }
        }
        return root;
        
    }
};
```

æ³¨æ„ï¼š
è¿™é‡Œå†™äº†é€’å½’æ–¹æ³•ï¼Œä½†è¿˜å¯ä»¥ç”¨é€’å½’å®ç°
***
2.å¯¹ç§°äºŒå‰æ ‘ï¼ˆ101ï¼‰
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/symmetric-tree/description/
é¢˜ç›®æè¿°ï¼š
ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œ æ£€æŸ¥å®ƒæ˜¯å¦è½´å¯¹ç§°ã€‚

æ–¹æ³•ï¼šè¿­ä»£
æ€è·¯ï¼š
- è¿­ä»£æ¯ä¸€å±‚çš„å…ƒç´ ï¼Œå°†å…¶å‹å…¥é˜Ÿåˆ—
- æ¯ä¸€å±‚å…ƒç´ å†ä¸€æ¬¡æ¨å…¥æ•°ç»„ï¼Œå¹¶ç”¨åŒæŒ‡é’ˆæ£€æŸ¥æ˜¯å¦å¯¹ç§°

å®ç°ï¼š
```
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        vector<int> res;
        if(root==nullptr)
        {
            return true;
        }
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty())
        {
            int n=que.size();
            vector<int> vec;
            for(int i=0;i<n;i++)
            {
                TreeNode* node=que.front();
                que.pop();
                if(node)
                {
                    que.push(node->right);
                    que.push(node->left);
                    vec.push_back(node->val);
                }
                else{
                    vec.push_back(-101);
                }
            }
             int left=0;
                int right=vec.size()-1;
                while(right>=left)
                {
                    if(vec[left]==vec[right])
                    {
                        left++;
                        right--;
                    }
                    else{
                        return false;
                    }
                }
        }
        return true;
        
    }
};
```

æ³¨æ„ï¼š
ä»ç„¶ä¹Ÿå¯ä»¥ç”¨é€’å½’å®ç°

***
3.äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ï¼ˆ104ï¼‰
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/maximum-depth-of-binary-tree/
é¢˜ç›®æè¿°ï¼š
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ root ï¼Œè¿”å›å…¶æœ€å¤§æ·±åº¦ã€‚

äºŒå‰æ ‘çš„ æœ€å¤§æ·±åº¦ æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿œå¶å­èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°ã€‚

æ–¹æ³•ï¼šé€’å½’
æ€è·¯ï¼š
- é€’å½’æ‰¾åˆ°æ¯ä¸ªç»“ç‚¹ï¼Œå¦‚æœè¿™ä¸ªç»“ç‚¹ä¸ä¸ºç©ºï¼Œåˆ™æ·±åº¦+1

å®ç°ï¼š
```
class Solution {
public:
    int find(TreeNode* node,int count)
    {
        if(node==nullptr)
        {
            return count-1;
        }
        int a=find(node->left,count+1);
        int b=find(node->right,count+1);
        return max(a,b);
    }
    int maxDepth(TreeNode* root) {
        if(!root)
        {
            return 0;
        }
        else{
            int a=find(root,1);
            return a;
        }

        
    }
};
```

***
4.äºŒå‰æ ‘çš„æœ€å°æ·±åº¦ï¼ˆ111ï¼‰
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/minimum-depth-of-binary-tree/description/
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œæ‰¾å‡ºå…¶æœ€å°æ·±åº¦ã€‚

æœ€å°æ·±åº¦æ˜¯ä»æ ¹èŠ‚ç‚¹åˆ°æœ€è¿‘å¶å­èŠ‚ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šçš„èŠ‚ç‚¹æ•°é‡ã€‚

è¯´æ˜ï¼šå¶å­èŠ‚ç‚¹æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

æ–¹æ³•ï¼šé€’å½’
æ€è·¯ï¼š
- è¿™é“é¢˜åˆ¤æ–­çš„å…³é”®åœ¨äºï¼Œåªæœ‰å½“å·¦å³ç»“ç‚¹å‡ä¸ºNULLæ—¶ï¼Œè¿™ä¸ªç»“ç‚¹æ‰å¯ä»¥åˆ¤æ–­ä¸ºå¶å­ç»“ç‚¹

å®ç°ï¼š
```
class Solution {
public:
    int find(TreeNode* cur)
    {
        if(cur==nullptr)
        {
            return 0;
        }
        int leftdep=find(cur->left);
        int rightdep=find(cur->right);
        if(cur->left&&!cur->right)
        {
            return 1+leftdep;
        }
        else if(cur->right&&!cur->left)
        {
            return 1+rightdep;
        }
        return min(1+leftdep,1+rightdep);

    }
    int minDepth(TreeNode* root) {
        if(root==nullptr)
        {
            return 0;
        }
        int res=find(root);
        return res;
        
    }
};
```

æ€»ç»“ï¼š
è¿™é“é¢˜åœ¨å¯»å¸¸é€’å½’ä¸Šå¢åŠ äº†ä¸€ç‚¹éš¾åº¦ï¼Œå¯ä»¥å¤ä¹ 

***
My opinionï¼š
å¯¹äºé€’å½’çš„æ“ä½œè¿˜æ˜¯ä¸å¤ªç†Ÿæ‚‰ï¼Œéœ€è¦å¤šåŠ ç»ƒä¹ 
***KEEEEEEEEp ğŸ•***

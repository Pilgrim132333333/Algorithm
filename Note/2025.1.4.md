
#1.4

1.é€’å¢å­åºåˆ—
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/non-decreasing-subsequences/
é¢˜ç›®æè¿°ï¼š
ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ‰¾å‡ºå¹¶è¿”å›æ‰€æœ‰è¯¥æ•°ç»„ä¸­ä¸åŒçš„é€’å¢å­åºåˆ—ï¼Œé€’å¢å­åºåˆ—ä¸­ è‡³å°‘æœ‰ä¸¤ä¸ªå…ƒç´  ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚

æ•°ç»„ä¸­å¯èƒ½å«æœ‰é‡å¤å…ƒç´ ï¼Œå¦‚å‡ºç°ä¸¤ä¸ªæ•´æ•°ç›¸ç­‰ï¼Œä¹Ÿå¯ä»¥è§†ä½œé€’å¢åºåˆ—çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µ

æ–¹æ³•ï¼šå›æº¯ï¼š

æ€è·¯ï¼š
- éš¾åº¦åœ¨äºå¦‚ä½•å»é‡
- æ–¹æ³•æ˜¯æ¯ä¸ªæéƒ½å»ºç«‹ä¸€ä¸ªunordered_setï¼Œè®°å½•è¿™ä¸ªæå·²ç»ä½¿ç”¨è¿‡çš„å…ƒç´ 

å®ç°ï¼š
```
class Solution {
private:
    vector<int> path;
    vector<vector<int>> res;
    void backtracing(int startindex,vector<int> nums)
    {
       vector<int> check;
       if(path.size()>=2)
       {
         res.push_back(path);
       }
       if(startindex>=nums.size())
       {
        return;
       }
       
        for(int i=startindex;i<nums.size();i++)
        {
            if((path.empty()||nums[i]>=path.back())&&find(check.begin(),check.end(),nums[i])==check.end())
            {
                path.push_back(nums[i]);
                backtracing(i+1,nums);
                path.pop_back();
                check.push_back(nums[i]);
                continue;
            }
        }
        return;
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        backtracing(0,nums);
        return res;
        
    }
};
```

***
2.å…¨æ’åˆ—
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/permutations/
é¢˜ç›®æè¿°ï¼š
ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ nums ï¼Œè¿”å›å…¶ æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ— ã€‚ä½ å¯ä»¥ æŒ‰ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚

æ–¹æ³•ï¼šå›æº¯

æ€è·¯ï¼š
- ä¸ç»„åˆç›¸æ¯”ï¼Œæ’åˆ—ä¸èƒ½è®°å½•startindexæ¥æ§åˆ¶éå†ï¼Œå¿…é¡»åœ¨æ¯æ¬¡é€’å½’æ—¶éƒ½éå†æ‰€æœ‰å…ƒç´ 
- è¿˜éœ€è¦ä¸€ä¸ªusedæ¥è®°å½•æ‰€æœ‰ä½¿ç”¨è¿‡çš„å…ƒç´ 

å®ç°ï¼š
```
class Solution {
private:
   vector<int> path;
   vector<vector<int>> res;
   void backtracing(vector<int> used,vector<int> nums)
   {
    if(path.size()==nums.size())
    {
        res.push_back(path);
        return;
    }
    for(int i=0;i<nums.size();i++)
    {
        if(find(used.begin(),used.end(),nums[i])==used.end())
        {
            path.push_back(nums[i]);
            used.push_back(nums[i]);
            backtracing(used,nums);
            path.pop_back();
            used.pop_back();
        }

    }

   }
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<int> used;
        backtracing(used,nums);
        return res;
        
    }
};
```

***
3.å…¨æ’åˆ—||
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/permutations-ii/
é¢˜ç›®æè¿°ï¼š
ç»™å®šä¸€ä¸ªå¯åŒ…å«é‡å¤æ•°å­—çš„åºåˆ— nums ï¼ŒæŒ‰ä»»æ„é¡ºåº è¿”å›æ‰€æœ‰ä¸é‡å¤çš„å…¨æ’åˆ—ã€‚

æ–¹æ³•ï¼šå›æº¯
æ€è·¯ï¼š
- å’Œä¸Šä¸€é“é¢˜åªæ˜¯å¤šäº†ä¸€ä¸ªå»é‡æ“ä½œ
- å’Œä¸Šä¸Šé¢˜çš„å»é‡æ“ä½œç›¸åŒï¼Œå½“ä»å·¦åˆ°å³éå†æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦è®°å½•å½“å‰æå·²ç»ä½¿ç”¨çš„å…ƒç´ å³å¯

å®ç°ï¼š
```
class Solution {
private:
   vector<int> path;
   vector<vector<int>> res;
   void backtracing(multiset<int> &mset,vector<int> nums)
   {
    if(path.size()==nums.size())
    {
        res.push_back(path);
        return ;
    }
    unordered_set<int> set;
    for(int i=0;i<nums.size();i++)
    {
        if(set.find(nums[i])==set.end()&&mset.find(nums[i])!=mset.end())
        {
            path.push_back(nums[i]);
            auto it=mset.find(nums[i]);
            mset.erase(it);
            backtracing(mset,nums);
            path.pop_back();
            mset.insert(nums[i]);
            set.insert(nums[i]);
        }
    }
    return;
   }
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        multiset<int> mset;
        for(int num:nums)
        {
            mset.insert(num);
        }
        backtracing(mset,nums);
        return res;
        
    }
};
```
***
My opinion:
ä¸‰é“éš¾é¢˜æ²¡å†™ï¼Œå®åœ¨æ˜¯æœ‰ç‚¹æ²¡ç©ºäº†ï¼Œçœ‹çœ‹æ˜å¤©èƒ½ä¸èƒ½å†™äº†

***Keeeeeepp ğŸ•***

#12.28

1.äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å€¼ï¼ˆ530ï¼‰
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/
é¢˜ç›®æè¿°ï¼š
ç»™ä½ ä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å› æ ‘ä¸­ä»»æ„ä¸¤ä¸åŒèŠ‚ç‚¹å€¼ä¹‹é—´çš„æœ€å°å·®å€¼ ã€‚

å·®å€¼æ˜¯ä¸€ä¸ªæ­£æ•°ï¼Œå…¶æ•°å€¼ç­‰äºä¸¤å€¼ä¹‹å·®çš„ç»å¯¹å€¼ã€‚

æ–¹æ³•ï¼šé€’å½’

æ€è·¯ï¼š
- å…ˆéå†å†æ’åº

å®ç°ï¼š
```
class Solution {
public:
    void traversal(TreeNode* node, vector<int> &vec)
    {
        if(!node)
        {
            return;
        }
        if(node->left)
        {
            traversal(node->left,vec);
        }
        vec.push_back(node->val);
        if(node->right)
        {
            traversal(node->right,vec);
        }
        return;
    }
    int getMinimumDifference(TreeNode* root) {
        vector<int> vec;
        traversal(root,vec);
        sort(vec.begin(),vec.end());
        int res=INT_MAX;
        for(int i=0;i<vec.size()-1;i++)
        {
            int j=i+1;
            res=min(res,abs(vec[i]-vec[j]));
        }
        return res;
        
    }
};
```

***
2.äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•°ï¼ˆ501ï¼‰
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/find-mode-in-binary-search-tree/description/
é¢˜ç›®æè¿°ï¼š
ç»™ä½ ä¸€ä¸ªå«é‡å¤å€¼çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ‰¾å‡ºå¹¶è¿”å› BST ä¸­çš„æ‰€æœ‰ ä¼—æ•°ï¼ˆå³ï¼Œå‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ï¼‰ã€‚

å¦‚æœæ ‘ä¸­æœ‰ä¸æ­¢ä¸€ä¸ªä¼—æ•°ï¼Œå¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ã€‚

å‡å®š BST æ»¡è¶³å¦‚ä¸‹å®šä¹‰ï¼š

ç»“ç‚¹å·¦å­æ ‘ä¸­æ‰€å«èŠ‚ç‚¹çš„å€¼ å°äºç­‰äº å½“å‰èŠ‚ç‚¹çš„å€¼
ç»“ç‚¹å³å­æ ‘ä¸­æ‰€å«èŠ‚ç‚¹çš„å€¼ å¤§äºç­‰äº å½“å‰èŠ‚ç‚¹çš„å€¼
å·¦å­æ ‘å’Œå³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘

æ–¹æ³•ï¼šé€’å½’ï¼Œæ˜ å°„

æ€è·¯ï¼š
- éå†å¹¶åˆ›å»ºmapï¼Œå†éå†map
- ï¼ˆä½†æ˜¯æ­¤æ–¹æ³•æ¯”è¾ƒæ…¢ï¼‰

å®ç°ï¼š
```
class Solution {
public:
    void traversal(TreeNode* node,unordered_map<int,int>& map)
    {
        if(!node)
        {
            return;
        }
        if(node->left)
        {
            traversal(node->left,map);
        }
        
        if(map.find(node->val)==map.end())
        {
            map.insert({node->val,1});
        }
        else{
            map[node->val]++;
        }

        if(node->right)
        {
            traversal(node->right,map);
        }

        return;
    }
    vector<int> findMode(TreeNode* root) {
        unordered_map<int,int> map;
        traversal(root,map);
        int key=0;
        int val=0;
        for(auto ele:map)
        {
            if(ele.second>val)
            {
                val=ele.second;
                key=ele.first;
            }
        }
        vector<int> res;
        for(auto ele:map)
        {
            if(ele.second==val)
            {
                res.push_back(ele.first);
            }
        }
        return res;

        
    }
};
```

***
3.äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ
é¢˜ç›®é“¾æ¥ï¼šhttps://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/
é¢˜ç›®æè¿°ï¼š
ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚

ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€

æ–¹æ³•ï¼šé€’å½’ï¼Œä¸€ç‚¹ç‚¹å›æº¯

æ€è·¯ï¼š
- ä¸»è¦æ˜¯å®ç°ä»å¶å­åˆ°rootéå†ï¼Œå†åœ¨éå†è¿‡ç¨‹ä¸­å®ç°å¥½å‚æ•°ä¼ é€’å°±å¯ä»¥
- ååºéå†å³å¯

å®ç°ï¼š
```
class Solution {
public:
    TreeNode* traversal(TreeNode* node,TreeNode* p,TreeNode* q)
    {
       if(!node)
       {
        return NULL;
       }
       TreeNode* a=NULL;
       TreeNode* b=NULL;
       a=traversal(node->left,p,q);
       b=traversal(node->right,p,q);
       if(a&&b)
       {
        return node;
       }
       if((node==p||node==q)&&(a||b))
       {
        return node;
       }
       if(a||b)
       {
        if(a)
        {
            return a;
        }
        if(b)
        {
            return b;
        }
       }
       if(node==p)
       {
        return p;
       }
       if(node==q)
       {
        return q;
       }
      return NULL;

    }
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        TreeNode* res=NULL;
        res=traversal(root,p,q);
        return res;
        
    }
};
```

***
My opinionï¼š
ä»Šå¤©ç¬¬ä¸‰é¢˜ç¡®å®æœ‰ç‚¹éš¾åº¦ï¼Œå€¼å¾—å¤šæ€è€ƒ
***ğŸ•***
